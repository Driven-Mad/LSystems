#include "lParser.h"

lParser::lParser()
{

}

lParser::~lParser()
{

}

bool lParser::writeObj(char * filepath, object lObj)
{
    //Object writer (ref old code - re-write for c++ 11
    bool success = false;
    return success;
}

bool lParser::loadObj(char * filepath, object &obj)
{
        //STORGE CONTAINERS

        //VERTICIES
        std::vector<unsigned int> vetexIndicies; //F 1,4,7
        std::vector<ngl::Vec3> t_Verts; //V

        //UV's
        std::vector<unsigned int> uvIndicies; //F 2,5,8
        std::vector<ngl::Vec2> t_UVs; //VT

        //NORMALS
        std::vector<unsigned int> normalIndicies;// F 3, 6,9
        std::vector<ngl::Vec3> t_Norms; //VN

        std::string line;
        std::ifstream myObjectFile(filepath);

        //Succesful Files REad
        bool success = false;
        if(myObjectFile.is_open()){
            printf("File has been opened \n");
        }

        if(myObjectFile.is_open()){
            while(std::getline(myObjectFile, line)){ //Going through every line of the document - PER LINE

                //////////////////////////////////////////
                //VERTICIES//////
                //////////////////////////////////////////
                if(line[0] == 'v' && line[1] == ' '){ //<---------- //If line starts with "V " then continue, did try V however got the whole document
                    std::vector<std::string> split_string; //Storage for our line to be split into
                    std::string buffer; //Buffer to store splitting of string
                    std::stringstream ss(line); //streaming the line
                    while(ss >> buffer){ // splits the string by white spaces
                        split_string.push_back(buffer); //Adds the seperate words into our storage for our  line split
                    }
                    if(split_string.size() > 4){
                        printf("File has too many options with verticies for our object loader, sorry. \n"); //ERROR checking incase theres more than just an Identifier,X,Y,Z
                        myObjectFile.close(); //close file

                        break;
                    }
                    ngl::Vec3 vert; //temp value to store the verticie
                    vert.m_x = std::stof(split_string[1]); //pass the value of the string and convert to a float (X)
                    vert.m_y = std::stof(split_string[2]);//pass the value of the string and convert to a float 󰀀
                    vert.m_z = std::stof(split_string[3]);//pass the value of the string and convert to a float (Z)
                    t_Verts.push_back(vert);//Add the verticie to our verticie storage.
                }// <------------


                //////////////////////////////////////////
                //UVS//////
                //////////////////////////////////////////
                if(line[0] == 'v' && line[1] == 't'){ //<---------- //If line starts with "VT" then continue
                    std::vector<std::string> split_string; //Storage for our line to be split into
                    std::string buffer; //Buffer to store splitting of string
                    std::stringstream ss(line); //streaming the line
                    while(ss >> buffer){ // splits the string by white spaces
                        split_string.push_back(buffer); //Adds the seperate words into our storage for our  line split
                    }
                    if(split_string.size() > 3){
                        printf("File has too many options with UVS for our object loader, sorry. \n"); //ERROR checking incase theres more than just an Identifier,X,Y
                        myObjectFile.close(); //close file
                        break;
                    }
                    ngl::Vec2 uv; //temp value to store the UV
                    uv.m_x = std::stof(split_string[1]); //pass the value of the string and convert to a float (X)
                    uv.m_y = std::stof(split_string[2]);//pass the value of the string and convert to a float 󰀀
                    t_UVs.push_back(uv);//Add the UV to our UVs storage.
                }// <------------


                //////////////////////////////////////////
                //NORMALS//////
                //////////////////////////////////////////
                if(line[0] == 'v' && line[1] == 'n'){ //<---------- //If line starts with "Vn" then continue
                    std::vector<std::string> split_string; //Storage for our line to be split into
                    std::string buffer; //Buffer to store splitting of string
                    std::stringstream ss(line); //streaming the line
                    while(ss >> buffer){ // splits the string by white spaces
                        split_string.push_back(buffer); //Adds the seperate words into our storage for our  line split
                    }
                    if(split_string.size() > 4){
                        printf("File has too many options with Normals for our object loader, sorry. \n"); //ERROR checking incase theres more than just an Identifier,X,Y,Z
                        myObjectFile.close(); //close file
                        break;
                    }
                    ngl::Vec3 norm; //temp value to store the normal
                    norm.m_x = std::stof(split_string[1]); //pass the value of the string and convert to a float (X)
                    norm.m_y = std::stof(split_string[2]);//pass the value of the string and convert to a float 󰀀
                    norm.m_z = std::stof(split_string[3]);//pass the value of the string and convert to a float (Z)
                    t_Norms.push_back(norm);//Add the normal to our normal storage.m_
                }// <------------

                //////////////////////////////////////////
                //Faces//////
                //////////////////////////////////////////
                if(line[0]=='f'){
                    ///////////SPLITTING AT SPACES
                    std::vector<std::string> split_string; //Storage for our line to be split into
                    std::string buffer; //Buffer to store splitting of string
                    std::stringstream ss(line); //streaming the line
                    while(ss >> buffer){ // splits the string by white spaces
                        split_string.push_back(buffer); //Adds the seperate words into our storage for our  line split
                    }
                    if(split_string.size() == 4)
                    {
                        //SPLITTING AT '/' in each 3 points
                        //Point 1 of the face
                        std::string buffer1;
                        std::stringstream face_point1(split_string[1]);
                        std::vector<std::string> face_point1_details;
                        while(std::getline(face_point1, buffer1, '/')){
                            face_point1_details.push_back(buffer1);
                        }
                        vetexIndicies.push_back(std::stoi(face_point1_details[0]));
                        uvIndicies.push_back(std::stoi(face_point1_details[1]));
                        normalIndicies.push_back(std::stoi(face_point1_details[2]));
                        //Point 2 of the face
                        std::string buffer2;
                        std::stringstream face_point2(split_string[2]);
                        std::vector<std::string> face_point2_details;
                        while(std::getline(face_point2, buffer2, '/')){
                            face_point2_details.push_back(buffer2);
                        }
                        vetexIndicies.push_back(std::stoi(face_point2_details[0]));
                        uvIndicies.push_back(std::stoi(face_point2_details[1]));
                        normalIndicies.push_back(std::stoi(face_point2_details[2]));
                        //Point 3 of the face
                        std::string buffer3;
                        std::stringstream face_point3(split_string[3]);
                        std::vector<std::string> face_point3_details;
                        while(std::getline(face_point3, buffer3, '/')){
                            face_point3_details.push_back(buffer3);
                        }
                        vetexIndicies.push_back(std::stoi(face_point3_details[0]));
                        uvIndicies.push_back(std::stoi(face_point3_details[1]));
                        normalIndicies.push_back(std::stoi(face_point3_details[2]));
                    }
                    if(split_string.size() == 5){

                        //SPLITTING AT '/' in each 3 points
                        //TRIANGLE 1
                        //Point 1 of the face
                        std::string buffer4;
                        std::stringstream face_point4(split_string[1]);
                        std::vector<std::string> face_point4_details;
                        while(std::getline(face_point4, buffer4, '/')){
                            face_point4_details.push_back(buffer4);
                        }
                        vetexIndicies.push_back(std::stoi(face_point4_details[0]));
                        uvIndicies.push_back(std::stoi(face_point4_details[1]));
                        normalIndicies.push_back(std::stoi(face_point4_details[2]));
                        //Point 2 of the face
                        std::string buffer5;
                        std::stringstream face_point5(split_string[2]);
                        std::vector<std::string> face_point5_details;
                        while(std::getline(face_point5, buffer5, '/')){
                            face_point5_details.push_back(buffer5);
                        }
                        vetexIndicies.push_back(std::stoi(face_point5_details[0]));
                        uvIndicies.push_back(std::stoi(face_point5_details[1]));
                        normalIndicies.push_back(std::stoi(face_point5_details[2]));
                        //Point 3 of the face
                        std::string buffer6;
                        std::stringstream face_point6(split_string[3]);
                        std::vector<std::string> face_point6_details;
                        while(std::getline(face_point6, buffer6, '/')){
                            face_point6_details.push_back(buffer6);
                        }
                        vetexIndicies.push_back(std::stoi(face_point6_details[0]));
                        uvIndicies.push_back(std::stoi(face_point6_details[1]));
                        normalIndicies.push_back(std::stoi(face_point6_details[2]));

                        //TRIANGLE 2
                        //SPLITTING AT '/' in each 3 points
                        //Point 1 of the face
                        std::string buffer1;
                        std::stringstream face_point1(split_string[2]);
                        std::vector<std::string> face_point1_details;
                        while(std::getline(face_point1, buffer1, '/')){
                            face_point1_details.push_back(buffer1);
                        }
                        vetexIndicies.push_back(std::stoi(face_point1_details[0]));
                        uvIndicies.push_back(std::stoi(face_point1_details[1]));
                        normalIndicies.push_back(std::stoi(face_point1_details[2]));
                        //Point 2 of the face
                        std::string buffer2;
                        std::stringstream face_point2(split_string[3]);
                        std::vector<std::string> face_point2_details;
                        while(std::getline(face_point2, buffer2, '/')){
                            face_point2_details.push_back(buffer2);
                        }
                        vetexIndicies.push_back(std::stoi(face_point2_details[0]));
                        uvIndicies.push_back(std::stoi(face_point2_details[1]));
                        normalIndicies.push_back(std::stoi(face_point2_details[2]));
                        //Point 3 of the face
                        std::string buffer3;
                        std::stringstream face_point3(split_string[4]);
                        std::vector<std::string> face_point3_details;
                        while(std::getline(face_point3, buffer3, '/')){
                            face_point3_details.push_back(buffer3);
                        }
                        vetexIndicies.push_back(std::stoi(face_point3_details[0]));
                        uvIndicies.push_back(std::stoi(face_point3_details[1]));
                        normalIndicies.push_back(std::stoi(face_point3_details[2]));
                    }
                    if(split_string.size() > 5){
                        //In non quads or triangles.
                        printf("File has too many options with faces for our object loader, sorry. \n try converting to triangles or quads. \n"); //ERROR checking incase theres more than just an Identifier,P1 details,P2 details,P3 details
                        myObjectFile.close(); //close filesuccess = true;
                        break;
                    }

                }

            }
            myObjectFile.close();

            for(size_t i = 0; i<vetexIndicies.size(); i++){
                    size_t vertexIndex = vetexIndicies[i];
                    size_t UVIndex = uvIndicies[i];
                    size_t normalIndex = normalIndicies[i];

                    ngl::Vec3 vertex = t_Verts[vertexIndex -1];
                    ngl::Vec2 UV = t_UVs[UVIndex -1];
                    UV.m_y = 1.0f - UV.m_y;
                    ngl::Vec3 normal = t_Norms[normalIndex -1];

                    //Pushing out of the function
                    obj.addVert(vertex);
                    obj.addUV(UV);
                    obj.addNormal(normal);
                    if(success != true)
                    {
                        success = true;
                    }
                }

        }else{
            //Error checking to see if file can be read or not.
            printf("File could not be read by this object loader, so sorry for any inconvinience. \n");
        }

    return success;
}

bool lParser::loadLObj(char * _lsytemstring_filepath, char* _variables_rules_filepath, lObject lObj)
{
    bool success = false;

    std::vector<std::string> temp_rules;
    std::string temp_LSystem_string;
    
    std::string line;
    std::ifstream myFile(_lsytemstring_filepath);

    //Succesful Files REad
    bool success = false;
    if(myObjectFile.is_open()){
        printf("File has been opened \n");
    }
    


    return success;

}


bool lParser::writeLObj(char * filepath, lObject lObj)
{
    bool success = false;
    return success;
}
